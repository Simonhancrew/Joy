#include <functional>
#include <map>
#include <unordered_set>
#include <vector>

using namespace std;

// 点被完全删除，所以要每个点能唯一的感染哪些block，顺序的做其实不太好做
// 但是遍历没感染的点，去找与之相连的init中的点，这样就能找到每个点能唯一感染哪些block
// 针对每个不在initial中的点做DFS，找到与initial中的点相连的点有多少个init中的点，只遍历没感染的点size
// 1. 只有一个，那么这个点删除后可以救size个
// 2. 有多个，删除了也能被另外的感染
// 最后算出哪个点删除后能救最多的点，没有就取最小的

class Solution {
public:
  int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial) {
    int n = graph.size();
    vector<int> vis(n);
    unordered_set<int> st(initial.begin(), initial.end());
    map<int, int> cnt;
    int node = -1, size = 0;
    function<void(int)> dfs = [&](int x) {
      vis[x] = 1;
      size++;
      for (int y = 0; y < n; ++y) {
        if (!graph[x][y])
          continue;
        if (st.contains(y)) {
          if (node != -2 && node != y) {
            node = node == -1 ? y : -2;
          }
        } else if (!vis[y]) {
          dfs(y);
        }
      }
    };
    for (int i = 0; i < n; i++) {
      if (st.contains(i) || vis[i]) {
        continue;
      }
      node = -1;
      size = 0;
      dfs(i);
      if (node >= 0) {
        cnt[node] += size;
      }
    }
    if (cnt.empty()) {
      return ranges::min(initial);
    }
    int mx = 0, ans = -1;
    for (const auto &[k, v] : cnt) {
      if (v > mx) {
        ans = k;
        mx = v;
      }
    }
    return ans;
  }
};
